# Basic State Management  
- 앱이 커질수록, 코드를 논리적으로 나누어서 관리를 해야한다.  
- 대표적인 방법으로는 Model-View separation( 데이터유닛과 유저의 UI의 부분을 논리적으로 나누어서 관리)    

### Model-View Separation  
- Model: 데이터를 저장하는 클래스, Flutter의 프레임워크와 동립적이다!   
- Views: 유저의 UI를 담당하는 클래스  
  
##### 직접하기  
1. lib 폴더 아래에 models 폴더를 만든후, 모델 클래스 생성:  
task.dart  
```
class Task{
  String description;
  bool complete;

  Task({
    this.complete = false,
    this.description = ""
});

}
```  
plan.dart  
```
import 'Task.dart';

class Plan{
  String name = "";
  final List<Task> tasks =[];
}
```  
data_layer.dart  
```
export "plan.dart";
export "Task.dart";
```  
- 위 model들을 사용할때, data_layer.dart를 import 하면 plan과 Task를 둘다 쓸수 있다!  
2. lib폴더 아래에 views 폴더 생성후, main.dart와 plan_screen.dart 파일 생성:   
main.dart  
```
import 'package:chapter6/views/plan_screen.dart';
import 'package:flutter/material.dart';

void main() {
  runApp(MasterPlanApp());
}

class MasterPlanApp extends StatelessWidget {
  const MasterPlanApp({Key? key}) : super(key: key);

  // This widget is the root of your application.
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      theme: ThemeData(
        primarySwatch: Colors.purple,
      ),
      home: PlanScreen(),
    );
  }
}
```    
paln_screen.dart    
```
class PlanScreen extends StatefulWidget
{
  const PlanScreen({Key? key}) : super(key: key);

  @override
  _PlanScreenState createState() => _PlanScreenState();
}

class _PlanScreenState extends State<PlanScreen>
{
  final plan = Plan();
  
  @override
  Widget build(BuildContext context) {
    return GestureDetector(                                                //유저가 textfield에 인풋을 넣고 난후에도, keyboard는 계속 보여진다.(textField가 focus를 가지고 있기 때문)
      onTap:(){                                                            //이 코드에서는 GestureDetector를 사용해서, 유저가 Scaffold의 어느부분이라도 탭하면, Scaffold의 child에  
        FocusScope.of(context).requestFocus(new FocusNode());;             //있던 focus가 Scaffold에게로 이동하여, keyboard를 닫게 한다!  
      },
      child: Scaffold(
        appBar: AppBar(
            title: Text("Master Plan")),
        body: _buildList(context),
        floatingActionButton: _buildAddTaskButton(context),
      ),
    );
  }

  Widget _buildAddTaskButton(BuildContext context)
  {
    return FloatingActionButton(
      child: Icon(Icons.add),
        onPressed: (){
        setState((){
          plan.tasks.add(Task());                                              //plan에 tasks를 더한후에 view를 업데이트
        });
        }
    );
  }

  Widget _buildList(BuildContext context)                                                          //list를 어떻게 만들지
  {
    return ListView.builder(
        itemCount: plan.tasks.length,
    itemBuilder: (context, index) {
      return _buildTaskTile(plan.tasks[index]);
    });
  }

  Widget _buildTaskTile(Task task)                                             //model을 사용해서 어떻게 view를 만들지 정함
  {                                                                            //controller function
    return ListTile(
      leading: Checkbox(
        value:task.complete,
        onChanged: (selected){                                                 //model을 변경시 다시 view를 업데이트!
          setState((){
            if(selected == null)
              {
                task.complete  = false;
              }
            else {
              task.complete = selected;
            }
          });
        },

        ),
        title: TextFormField(
            initialValue: task.description,
          onFieldSubmitted: (text){
              setState((){
                task.description = text;
              });
          },
      )
    );
  }
}
```  
- 위 코드에서는 Plan과 Task라는 클래스를 사용해서 Model을 만들고, PlanScreen 클래스를 사용해서 유저의 UI를 구성하였다.
- 위 코드는 데이터를 저장하는 Model 클래스와 Model 클래스들을 사용해서 UI를 만드는 PlanScreen 클래스를 따로 만들었지만, PlanScreen 클래스가 Model 클래스를 직접적으로 access하기 때문에, 더 분리 되어야함. 
  
![01_앱사진]()
### Managing the data layer with InheritedWidget  
- InheritedWidget => 이 위젯의 child들에게 쉽게 데이터를 전달할수 있게 하기위해서 사용.  
- 여러 widget들이 똑같은 데이터를 사용하고, 트리가 복잡해지면 InheritedWidget을 사용해서 똑같은 데이터를 사용하는게 중요하다.  
  
##### 직접하기  
1. plan_provider.dart 파일 생성:  
```
import 'package:chapter6/models/data_layer.dart';
import 'package:flutter/material.dart';

class PlanProvider extends InheritedWidget
{
  final _plan = Plan();

  PlanProvider({Key? key, required Widget child}): super(key : key, child: child);

  @override
  bool updateShouldNotify(InheritedWidget oldWidget) => false;

  static Plan? of(BuildContext context)
  {
    final provider = context.dependOnInheritedWidgetOfExactType<PlanProvider>();

    return provider?._plan;
  }

}
```  
- updateShouldNotify -> 해당 InheritedWidget의 parent가 setState를 호출했을때, 해당 InheritedWidget의 child가 rebuild해야되는지 말지를 정하는 함수  
- context.dependOnInheritedWidgetOfExactType<PlanProvider>(); -> 해당 context에서 시작하여 위로가서 제일 가까운 PlanProvider를 찾는다!  
  
2. main.dart를 아래와 같이 변경:  
```
import 'package:chapter6/plan_provider.dart';
import 'package:chapter6/views/plan_screen.dart';
import 'package:flutter/material.dart';

void main() {
  runApp(MasterPlanApp());
}

class MasterPlanApp extends StatelessWidget {
  const MasterPlanApp({Key? key}) : super(key: key);

  // This widget is the root of your application.
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Flutter Demo',
      theme: ThemeData(
        primarySwatch: Colors.purple,
      ),
      home: PlanProvider(
          child: PlanScreen()),
    );
  }
}
```  
- child를 view를 담당하는 위젯을 사용  
  
3. plan_screen.dart를 아래와 같이 바꿈:  
```
  import 'package:flutter/material.dart';
import '../plan_provider.dart';
import "/models/data_layer.dart";

class PlanScreen extends StatefulWidget
{
  const PlanScreen({Key? key}) : super(key: key);

  @override
  _PlanScreenState createState() => _PlanScreenState();
}

class _PlanScreenState extends State<PlanScreen>
{
  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap:(){
        FocusScope.of(context).requestFocus(new FocusNode());;
      },
      child: Scaffold(
        appBar: AppBar(
            title: Text("Master Plan")),
        body: _buildList(context),
        floatingActionButton: _buildAddTaskButton(context),
      ),
    );
  }

  Widget _buildAddTaskButton(BuildContext context)
  {
    final Plan plan = PlanProvider.of(context) ?? Plan();

    return FloatingActionButton(
      child: Icon(Icons.add),
        onPressed: (){
        setState((){
          plan.tasks.add(Task());                                              //plan에 tasks를 더한후에 view를 업데이트
        });
        }
    );
  }

  Widget _buildList(BuildContext context)                                                          //list를 어떻게 만들지
  {
    final Plan plan = PlanProvider.of(context) ?? Plan();

    return ListView.builder(
        itemCount: plan.tasks.length,
    itemBuilder: (context, index) {
      return _buildTaskTile(plan.tasks[index]);
    });
  }

  Widget _buildTaskTile(Task task)                                             //model을 사용해서 어떻게 view를 만들지 정함
  {                                                                            //controller function
    return ListTile(
      leading: Checkbox(
        value:task.complete,
        onChanged: (selected){                                                 //model을 변경시 다시 view를 업데이트!
          setState((){
            if(selected == null)
              {
                task.complete  = false;
              }
            else {
              task.complete = selected;
            }
          });
        },

        ),
        title: TextFormField(
            initialValue: task.description,
          onFieldSubmitted: (text){
              setState((){
                task.description = text;
              });
          },
      )
    );
  }

}
```  
- Plan객체를 PlanScreenState에서 생성하고 바꾸는 것이 아니라, PlanProvider를 사용해서 access하고 변경한다.  
- InheritedWidget의 데이터를 사용시 "final Plan plan = PlanProvider.of(context) ?? Plan();"     
- PlanProvider.of(context)를 사용해서 제일 가까운 PlanProvider의 Plan 객체를 엑세스 한다!  
- 위와같은 방식을 사용시, 여러 위젯이 같은 데이터를 사용할수 있다.  
  
### Making the app state visible across multiple screens  
- 위와같은 방법을 사용시, 스크린을 이동할때, PlanProvider안에 있는 데이터가 사라짐.
- 



