# The Future is Now: Introduction to Asynchronous Programming  
- asynchronous operation: main line of execution을 멈추지 않는다! 
- Dart는 싱글 쓰레드 언어를 사용한다. 
- 이때, 동시에 여러개의 task를 처리하는것 처럼 보이려면, Future라는 객체를 사용하여 Asynchronous Programming을 가능하게 만들수 있다!  
- Asynchronous Programming은 Web Service, Database, 기기의 Coordinate를 찾을때 사용!  
  
##### 직접하기:  
1. 앱이 인터넷을 사용하려면 pubspec.yaml에 아래코드를 추가:  
```
dependencies:
  flutter:
    sdk: flutter
  http: ^0.13.1               //인터넷 사용가능
```  
  
2. main.dart에 아래의 코드를 추가 
```
import 'package:flutter/material.dart';
import 'dart:async';
import 'package:http/http.dart' as http;
import 'package:http/http.dart';


void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({Key? key}) : super(key: key);

  // This widget is the root of your application.
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Flutter Demo',
      theme: ThemeData(
        primarySwatch: Colors.blue,
        visualDensity: VisualDensity.adaptivePlatformDensity
      ),
      home: FuturePage(),
    );
  }
}

class FuturePage extends StatefulWidget
{

  const FuturePage({Key? key}) : super(key: key);

  @override
  _FuturePageState createState() => _FuturePageState();
}

class _FuturePageState extends State<FuturePage>
{
  String result = "hello";
  bool isFetching = false;                             //현제 엡이 인터넷에서 데이터를 가져오는 중인지

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text("Back From the Future"),

      ),
      body:Center(
        child:Column(
          children: [
            Spacer(),
            ElevatedButton(
                child: Text("Go!"),
            onPressed: _onPressed,),
            Spacer(),
            Text(result),
            Spacer(),
            isFetching? CircularProgressIndicator(): SizedBox.shrink(),                                       //현제 무엇을 기다리는것 처럼 돌아감!
            Spacer()
          ],
        )
      )
    );
  }

  void _onPressed()
  {
    isFetching = true;

    result = '';                                                            //누를시 text를 초기화한다!
    setState(() {

    });

    getData()               
    .then((Response value){                                                 //fetching 성공시 response의 body를 String의 변경후 디스플레이!
      result = value.body.toString().substring(0, 450);
      setState((){
        isFetching = false;
      });
    }).catchError((_){                                                      //fetching 실패시
      result = "An error occurred";
      setState(() {
        isFetching = false;
      });
    });
  }

  Future<Response> getData() async{
    final String authority = "www.googleapis.com";                           //도메인
    final String path = "/books/v1/volumes/junbDwAAQBAJ";                    //path
    Uri url = Uri.https(authority, path);                                    //도메인과 path를 합쳐서 url을 만든다
    return http.get(url);                                                    //url의 결과값을 Response 객체로 리턴
  }
}
```  
-  isFetching? CircularProgressIndicator(): SizedBox.shrink() => isFetching이 true면 기다린다는 표시를 하는 CircularProgressIndicator를 보여주고, 아니면 SizedBox.shrink() 
-  SizedBox.shrink()는 아무것도 없는 empty 위젯이다. 
-  Future<T>는 generic class로써 T는 Future가 가지고 있는 데이터의 타입이다. 
- Future의 then((T value){})와 catchError((_){})를 사용하여, 요청한 작업이 완료돼었을때 무엇을 해야되는지 지정할수 있다. 
- Future를 사용하여, 계속 기다리지 않고, 완료가 돼었을때 해당작업을 수행하여 더욱더 효과적이게 일을 처리할수있다!
- async 키워드는 wait만 쓸때 필수지만, asynchronous coding을할때, Future를 리턴하는 함수에는 async 키워드를 넣는게 코딩할때 더 편리하다!
  
### Using async/await to remove callbacks  
- async => 함수가 Future를 사용하여 asynchronous programming을 한다고 알리는 키워드.
- await => Future가 끝날때까지 기다린후, 값을 리턴! 여기서 await를 써도 mainThread는 블락하지 않는다!  
코드:  
```
import 'dart:async';
import 'dart:core';
import 'package:flutter/material.dart';
import 'package:http/http.dart' as http;
import 'package:http/http.dart';


void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({Key? key}) : super(key: key);

  // This widget is the root of your application.
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Flutter Demo',
      theme: ThemeData(
        primarySwatch: Colors.blue,
        visualDensity: VisualDensity.adaptivePlatformDensity
      ),
      home: FuturePage(),
    );
  }
}

class FuturePage extends StatefulWidget
{

  const FuturePage({Key? key}) : super(key: key);

  @override
  _FuturePageState createState() => _FuturePageState();
}

class _FuturePageState extends State<FuturePage>
{
  String result = "hello";
  bool isFetching = false;

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text("Back From the Future"),

      ),
      body:Center(
        child:Column(
          children: [
            Spacer(),
            ElevatedButton(
                child: Text("Go!"),
            onPressed: count,),
            Spacer(),
            Text(result),
            Spacer(),
            isFetching? CircularProgressIndicator(): SizedBox.shrink(),                                  
            Spacer()
          ],
        )
      )
    );
  }

  void _onPressed()
  {
    isFetching = true;

    result = '';
    setState(() {

    });

    getData()
    .then((Response value){
      result = value.body.toString().substring(0, 450);
      setState((){
        isFetching = false;
      });
    }).catchError((_){
      result = "An error occurred";
      setState(() {
        isFetching = false;
      });
    });
  }

  Future<Response> getData() async{
    final String authority = "www.googleapis.com";
    final String path = "/books/v1/volumes/junbDwAAQBAJ";
    Uri url = Uri.https(authority, path);
    return http.get(url);
  }

  Future<int> returnOneAsync() async{                                      //3초 기다린후 1 리턴
    await Future<void>.delayed(const Duration(seconds: 3));
    return 1;
  }

  Future<int> returnTwoAsync() async{
    await Future<void>.delayed(const Duration(seconds: 3));                //3초 기다린후 2 리턴
    return 2;
  }

  Future<int> returnThreeAsync() async{             
    await Future<void>.delayed(const Duration(seconds: 3));                //3초 기다린후 3 리턴
    return 3;
  }

  Future count() async{                                                    //main Thread를 블락하지 않는다!
    result = '';
    int total = 0;
    total = await returnOneAsync();
    total += await returnTwoAsync();
    total += await returnThreeAsync();
    setState(() {
      result = total.toString();
    });

  }
}
```  
- async/wait 쓰는 이유는 asynchronous한 일들을 순서대로 처리할때 then()문을 쓰면 callback을 엄청 많이 써야되기 때문이다.  

### Using Futures with StatefulWidget
- Stateful Widget의 중요한 lifecycle function은 아래와 같다:  
1. initState(): State가 새로 만들어질때 부르는함수! 변수에 값을 지정하는 함수이다!
2. build(): UI를 부수고, 다시 build할때!
3. deactivate()/ dispose(): 위젯이 트리에서 없어질때 호출되는 함수!
  
##### 예제코드  
```
import 'package:flutter/material.dart';
import 'package:geolocator/geolocator.dart';

class LocationScreen extends StatefulWidget
{
  const LocationScreen({Key? key}) : super(key: key);

  @override
  _LocationScreenState createState() => _LocationScreenState();
}

class _LocationScreenState extends State<LocationScreen> {
  String myPosition = '';
  @override
  void initState()
  {
    getPosition().then((Position? myPos){
      if(myPos == null){
        myPosition = "Unable to get the value";
        return;
      }

      myPosition = "Latitude: " + myPos.latitude.toString() + " - Longtitude: "
          + myPos.longitude.toString();
    }).catchError((_){
      myPosition = "error occurred";
    });

    setState(() {
      myPosition = myPosition;
    });

    super.initState();

  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text("Current Location")
      ),
      body: Center(
          child: Text(myPosition))
    );
  }

  Future<Position?> getPosition() async {
    bool serviceEnabled;
    LocationPermission permission;

    // location 서비스가 활성화 되어있는지
    serviceEnabled = await Geolocator.isLocationServiceEnabled();
    if (!serviceEnabled) {
      return Future.error('Location services are disabled.');
    }

    //퍼미션이 있는지 체크, 없으면 request한후 다시 체크!
    permission = await Geolocator.checkPermission();
    if (permission == LocationPermission.denied) {
      permission = await Geolocator.requestPermission();
      if (permission == LocationPermission.denied) {
        // Permissions are denied, next time you could try
        // requesting permissions again (this is also where
        // Android's shouldShowRequestPermissionRationale
        // returned true. According to Android guidelines
        // your App should show an explanatory UI now.
        return Future.error('Location permissions are denied');
      }
    }

    //퍼미션이 영원히 deny될때!
    if (permission == LocationPermission.deniedForever) {
      // Permissions are denied forever, handle appropriately.
      return Future.error(
          'Location permissions are permanently denied, we cannot request permissions.');
    }

    // When we reach here, permissions are granted and we can
    // continue accessing the position of the device.
    return await Geolocator.getCurrentPosition();
  }

}
```  
- 위에는 유저의 location이 한번만 알면 되어서, initState()에서 Future를 처리했다!  
- 위 코드는 Geolocator를 사용하여 유저의 coordinate를 가져오는 코드이다.
- 안드로이드 사용시 android폴더 안에 AndroidManifest.xml에 아래와 같이 코드를 추가!  
![04_androidManifest]()
- 또, 아래와같이 pubspec.yml에 dependencies를 추가!  
![05_pubspec.yml]()  
  
### Using FutureBuilder to let Flutter Manage your Futures


