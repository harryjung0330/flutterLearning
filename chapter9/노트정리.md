# Advanced State Management with Streams  
- Stream: 연속적인 binary 데이터값을 asynchronous하게 도착할때 사용!  
- Stream에서 데이터를 가져오려면 Subsribe를 해야한다!  
  
### How to use Dart Streams  
  
##### 직접하기
1. main.dart  
```
import 'package:flutter/material.dart';
import "stream.dart";

void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({Key? key}) : super(key: key);

  // This widget is the root of your application.
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Stream',
      theme: ThemeData(
        primarySwatch: Colors.deepPurple,
        visualDensity: VisualDensity.adaptivePlatformDensity
      ),
      home: StreamHomePage() ,
    );
  }
}

class StreamHomePage extends StatefulWidget
{
  const StreamHomePage({Key? key}) : super(key: key);

  @override
  _StreamHomePageState createState() => _StreamHomePageState();
}

class _StreamHomePageState extends State<StreamHomePage> {
  late Color bgColor = Colors.red;
  late ColorStream colorStream;

  changeColor() async{
    await for (var eventColor in colorStream.getColors())
      {
        setState((){
          bgColor = eventColor;
        });
      }
  }

  @override
  void initState(){
    colorStream = ColorStream();
    changeColor();
    super.initState();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text("Stream")
      ),
      body: Container(
        decoration: BoxDecoration(
          color:bgColor
        )
      )
    );
  }

}
```  
- await for => Stream에서 나오는 event 데이터를 계속 listen한다!  
2. stream.dart  
```
import 'package:flutter/material.dart';

class ColorStream{

  Stream<Color> getColors() async*{                       //async* Stream을 사용할때 

    final List<Color> colors = [
      Colors.blueGrey,
      Colors.amber,
      Colors.deepPurple,
      Colors.lightBlue,
      Colors.teal
    ];

    yield* Stream.periodic(Duration(seconds: 1), (int t){           //t=> 몇초가 지났는지
      int index = t % 5;
      return colors[index];
    });

  }

}
```  
- Future는 하나의 event만 관여하지만 Stream은 여러 event를 관여한다!
- *async => generator함수를 생성한다!
- yield* Stream함수내에서 return이라고 생각하면 된다. 하지만, return과는 다르게 실행후 함수를 리턴하지 않는다!  
- Stream.periodic(Duration, (int) {}) -> Stream을 만드는 constructor! 여러개의 event를 생성한다! 위헤서는 리스트안에 있는 칼라중 하나를 리턴하는 이벤트!  

##### There's more  
- await for 대신 listen함수를 써서 stream의 데이터를 사용할수 있다!  
```
colorStream.getColors().listen((eventColor){
    setState((){
      bgColor = eventColor;
      });
    });
```  
- 차이점은 listen()함수후에 오는 코드는 실행이 Synchronous하게 되는 반면에 await for 후에 오는 코드들은 stream의 데이터들이 다 나오고 처리가 될때까지 기다려야된다!  

### Using Stream Controllers and Sinks
- StreamController는 Stream과 Sink(Stream에 event를 삽입)을 연결시킨다.  
1. main.dart  
```
import 'package:flutter/material.dart';
import "stream.dart";
import "dart:async";
import "dart:math";

void main() {
  runApp(const MyApp());
}

class MyApp extends StatelessWidget {
  const MyApp({Key? key}) : super(key: key);

  // This widget is the root of your application.
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Stream',
      theme: ThemeData(
        primarySwatch: Colors.deepPurple,
        visualDensity: VisualDensity.adaptivePlatformDensity
      ),
      home: StreamHomePage() ,
    );
  }
}

class StreamHomePage extends StatefulWidget
{
  const StreamHomePage({Key? key}) : super(key: key);

  @override
  _StreamHomePageState createState() => _StreamHomePageState();
}

class _StreamHomePageState extends State<StreamHomePage> {
  late Color bgColor = Colors.red;
  late ColorStream colorStream;

  int lastNumber = 0;
  late StreamController numberStreamController;

  void addRandomNumber()
  {
    Random random = Random();
    int myNum = random.nextInt(10);
    numberStream.addNumberToSink(myNum);
  }

  @override
  void initState(){
    numberStream = NumberStream();
    numberStreamController = numberStream.controller;
    Stream stream = numberStreamController.stream;
    stream.listen((event){
      setState(() {
        lastNumber = event;
      });
    });

    super.initState();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text("Stream")
      ),
      body: Container(
        width: double.infinity,
        child:Column(
          mainAxisAlignment: MainAxisAlignment.spaceEvenly,
          crossAxisAlignment: CrossAxisAlignment.center,
          children: [
            Text(lastNumber.toString()),
            ElevatedButton(onPressed: () => addRandomNumber(), child: Text("New Random Number"))
          ],
        )
      )
    );
  }
}
```  
2. stream.dart 
```
import 'package:flutter/material.dart';
import "dart:async";

class ColorStream{
  Stream<Color> getColors() async*{

    final List<Color> colors = [
      Colors.blueGrey,
      Colors.amber,
      Colors.deepPurple,
      Colors.lightBlue,
      Colors.teal
    ];

    yield* Stream.periodic(Duration(seconds: 1), (int t){           //t=> 몇초가 지났는지
      int index = t % 5;
      return colors[index];
    });

  }
}

class NumberStream{
  StreamController<int> controller = StreamController<int>();

  addNumberToSink(int newNumber)
  {
    controller.sink.add(newNumber);
  }

  close()
  {
    controller.close();
  }

}
```
- streamController에서는 sink를 통해서 controller에 데이터를 추가하고, stream을 통해서 넣었던 데이터를 뺀다!  
- Controller.sink -> 해당 controller에 sink 리턴  
- Sink.add()를 통해서 데이터를 추가  
- StreamController<T> -> T 데이터 타입을 받는 StreamController. 
- StreamController.stream => 해당 Controller의 Stream을 리턴! 이 stream을 listen하면 sink로 add될때 이벤트가 리턴된다!  
  
##### There's more  
- StreamController를 통해서 error 핸들링을 할수있다!
1. Controller.sink.addError(String errorMessage); -> Stream에서 listen을 할때 error를 생성한다!  
2. stream에서 에러를 handle하려면 -> stream.listen((event) {}).onError((errorMsg){});로 error handle!. 
  
### Injecting Data Transform into Streams
- Stream에서 꺼내온 데이터를 바로 쓸때도 있지만, 꺼내온 데이터를 변환 시킨후에 사용하는 경우도 많다!  
- 이런 경우에 StreamTransformer를 사용하면 된다!  
```

```
