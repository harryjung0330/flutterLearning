# Adding Interactivity and Navigation to Your App   
- UI -> 스크린위의 모든 element: images, colors, panels, text, and so on.
- UX -> how ui interact with each other!  
  
### Adding State to Your App  
- Stateful widgets -> 정보를 저장하는 위젯이다, state가 변화될때, 위젯을 다시 만드는법을 안다.
  
##### 직접하기  
- main.dart를 아래와 같은 코드로 변경  
```
import 'package:flutter/material.dart';
import 'StopWatch.dart';

void main() {
  runApp(const StopwatchApp());
}

class StopwatchApp extends StatelessWidget {
  const StopwatchApp({Key? key}) : super(key: key);

  // This widget is the root of your application.
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: 'Flutter Demo',
      theme: ThemeData(
        primarySwatch: Colors.blue,
      ),
      home: StopWatch()
    );
  }
}
```  
  
- StopWatch.dart를 아래와 같은 코드로 변경

```
import 'dart:async';
import 'package:flutter/material.dart';

class StopWatch extends StatefulWidget
{
  @override
  State createState() => StopWatchState();
}

class StopWatchState extends State<StopWatch>
{
  int seconds = 0;
  Timer? timer = null;

  @override
  void initState()
  {
    super.initState();

    seconds = 0;
    timer = Timer.periodic(Duration(seconds: 1), _onTick);                                //Timer는 객체가 생성되자 마자 시간이 돌아감!
  }

  void _onTick(Timer time)                                            
  {
    setState((){
      ++seconds;
    });
  }

  @override
  void dispose()
  {
    timer?.cancel();
    super.dispose();
  }


  @override
  Widget build(BuildContext context)
  {
    return Scaffold(
      appBar: AppBar(
        title: Text("StopWatch")
      ),
      body: Center(
        child: Text(
          "$seconds ${_secondsText()}",
          style: Theme.of(context).textTheme.headline5
        )
      )
    );
  }

  String _secondsText()  => seconds == 1 ? "second" : "seconds";
}
```  
- 위에서 StatefulWidget을 extend하는 StopWatch는 크게 기능이 없다. 
- State를 extend하는 StopWatchState는 계속 바뀔수 있다. 
- setState(() => {}) -> 함수를 받는 함수로, 이 함수가 호출되면 위젯이 다시 그려진다.
- process: setState() -> widget은 더럽다고 표시됨! -> 플러터는 더럽다고 표시된 위젯을 다시 rebuild -> build()가 호출됨!  
- Timer.periodic(Duration(seconds: 1), _onTick))   
   -> Duration(): 몇초마다 함수가 호출될건지  
   -> _onTick(): 어떤 함수가 호출이 될건지  
- State 클래스는 라이프 사이클을 가지고 있다 (아래 순서대로 호출됨!) :  
   -> initState -> widget이 트리에 속하기 전에 호출되는 함수이다. 따라서, 위젯은 BuildContext property를 접근할수가 없다. 보통 field 변수를 initialize하는데 사용!
   -> didChangeDependencies -> intiState함수 호출후에!, 이 함수는 BuildContext를 access할수 있다! 
   -> didUpdateWidget  
   -> build(required) -> UI가 만들어지는 단계
   -> reassemble  
   -> deactivate  
   -> dispose  -> State 객체가 위젯트리에서 없어질때, 사용하는 리소스를 정리하고, memory leak을 방지!

##### Interacting with Buttons  
- Button을 사용해서 스탑워치를 구현해본다!
- StopWatch.dart를 아래와 같이 바꾼다:  
```
import 'dart:async';
import 'package:flutter/material.dart';

class StopWatch extends StatefulWidget
{
  @override
  State createState() => StopWatchState();
}

class StopWatchState extends State<StopWatch>
{
  int seconds = 0;
  Timer? timer = null;
  bool? isTicking;

  @override
  void initState()
  {
    super.initState();

  }

  void _onTick(Timer time)
  {
    setState((){
      ++seconds;
    });
  }

  @override
  void dispose()
  {
    timer?.cancel();
    super.dispose();
  }


  @override
  Widget build(BuildContext context)
  {
    return Scaffold(
      appBar: AppBar(
        title: Text("StopWatch")
      ),
      body: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Text(
            "$seconds ${_secondsText()}",
            style: Theme.of(context).textTheme.headline5
          ),
          SizedBox(height: 20,),
          Row(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [ElevatedButton(
                style: ButtonStyle(
              backgroundColor: MaterialStateProperty.all<Color>(Colors.green)),
                onPressed:_startTimer,
            child: Text("start!"))],
          ),
          SizedBox(width: 20,),
          TextButton(
            style: ButtonStyle(
              backgroundColor: MaterialStateProperty.all<Color>(Colors.red),
              foregroundColor: MaterialStateProperty.all<Color>(Colors.white),
            ),
            onPressed: _stopTimer,
            child: Text("Stop"),
          )
        ],
      )
    );
  }

  void _startTimer()
  {
    if(isTicking != null)                                                                       //ticking이 null이 아니면, 타이머가 생성이 됐었다는 뜻이니!
      return;

    timer = Timer.periodic(Duration(seconds: 1), _onTick);                                      //timer 생성

    setState((){
      seconds = 0;
      isTicking = true;
    });
  }

  void _stopTimer()                                                                             //isTicking이 true가 아니면 타이머를 멈출 필요가 없다! 
  {
    if( isTicking != true)
      return;
    
    timer?.cancel();                                                                                                                                                     

    setState((){                                                                                
      isTicking = false;
    });

  }

  String _secondsText()  => seconds == 1 ? "second" : "seconds";
}
```  
- Flutter -> supplies multiple button types: ElevatedButton, TextButton, IconButton, FloatingActionButton, DropDownButton, CupertinoButton
- 위의 버튼은 디자인만 다르다!
- Button: (child: , onPressed:) 두개의 property가 있다.  
  
##### Making it Scroll  
- ListView -> widget for scrolling
- 사용법:  
```
final laps = <int>[];
Widget _buildLapDisplay()                                       //현제 ListView를 보여줌!
  {
    return ListView(
      children: [
        for (int milliseconds in laps)                          //listView의 Children에 원하는 위젯을 넣어서, ListView를 생성! 
          ListTile(                                             //여기서는 ListTile들을 넣어서 ListView의 child를 구성! 
            title: Text(_secondsText(milliseconds))    
          )]
    );
  }
```  
- ListTile -> ListTile({  
Key key,   
Widget leading,   
Widget title,   
Widget subtitle,   
Widget trailing,   
bool isThreeLine: false,   
bool dense,  
VisualDensity visualDensity,   
ShapeBorder shape,   
EdgeInsetsGeometry contentPadding,   
bool enabled: true,   
GestureTapCallback onTap,   
GestureLongPressCallback onLongPress,   
MouseCursor mouseCursor,   
bool selected: false,   
Color focusColor,   
Color hoverColor,   
FocusNode focusNode,   
bool autofocus: false,   
Color tileColor, Color selectedTileColor  
})   
- ListTile은 위와같은 Property를 가지고 있는 Widget이다. 보통 ListView에 widget으로 사용됨!
- ListView는 parent의 크기가 한정적이어야 한다. 따라서, Column과 같은 constraint가 정해지지 않은 Widget은 ListView의 parent가 될수없다! Column의 Child를 expanded, Expanded의 child를 ListView로 해서, 사용한다!  
- 아니면 Flexible을 사용가능!
  
##### Handling Large Dataset with List Bundles  
- ListView는 자기의 View들을 재활용하지 않는다. 하지만, 화면안에는 한정된 View만 보일수 있기때문에 이 view들을 재활용할수 있다. 
- 
